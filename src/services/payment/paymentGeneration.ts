
import { supabase, handleSupabaseError, addDatePeriod } from '@/lib/supabase';
import { PaymentData, getPaymentFrequency } from './types';

export const generateHistoricalPayments = async (
  leaseId: string, 
  rentAmount: number, 
  firstPaymentDate: string, 
  frequency: string,
  currentDate: string = new Date().toISOString().split('T')[0]
): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    const paymentFrequency = getPaymentFrequency(frequency);
    const startDate = new Date(firstPaymentDate);
    const endDate = new Date(currentDate);
    
    if (startDate > endDate) {
      return { data: null, error: "La date du premier paiement ne peut pas être postérieure à la date actuelle" };
    }
    
    // Check if initial payments (deposit/agency fees) already exist
    const { data: existingPayments, error: checkError } = await supabase
      .from('payments')
      .select('id, payment_type')
      .eq('lease_id', leaseId)
      .in('payment_type', ['deposit', 'agency_fee', 'initial']);
      
    if (checkError) {
      console.error('Error checking for existing payments:', checkError);
      return { data: null, error: checkError.message };
    }
    
    const payments: PaymentData[] = [];
    let currentDueDate = new Date(startDate);
    
    // Generate regular payments until current date
    let paymentNumber = 1;
    while (true) {
      if (paymentNumber > 1) {
        // Add the frequency interval for subsequent payments
        currentDueDate = addDatePeriod(
          currentDueDate, 
          paymentFrequency.periodAmount, 
          paymentFrequency.periodUnit
        );
      }
      
      // Stop if we've gone past the current date
      if (currentDueDate > endDate) break;
      
      const payment: PaymentData = {
        leaseId,
        amount: rentAmount,
        dueDate: currentDueDate.toISOString().split('T')[0],
        paymentDate: currentDueDate.toISOString().split('T')[0], // Add payment_date to fix the not-null constraint error
        paymentMethod: 'bank_transfer',
        status: 'undefined',
        paymentType: 'rent',
        isAutoGenerated: true,
        notes: `Paiement régulier #${paymentNumber} généré automatiquement`
      };
      
      payments.push(payment);
      paymentNumber++;
    }
    
    // Insert payments to database
    if (payments.length > 0) {
      const paymentsToInsert = payments.map(p => ({
        lease_id: p.leaseId,
        amount: p.amount,
        due_date: p.dueDate,
        payment_date: p.paymentDate, // Include payment_date in the insert
        payment_method: p.paymentMethod,
        status: p.status,
        payment_type: p.paymentType,
        is_auto_generated: p.isAutoGenerated,
        notes: p.notes
      }));
      
      const { data, error } = await supabase
        .from('payments')
        .insert(paymentsToInsert)
        .select();
        
      if (error) return handleSupabaseError(error);
      
      // Transform snake_case to camelCase for the return value
      const transformedData = data.map(payment => ({
        id: payment.id,
        leaseId: payment.lease_id,
        amount: payment.amount,
        paymentDate: payment.payment_date,
        dueDate: payment.due_date,
        paymentMethod: payment.payment_method,
        status: payment.status,
        transactionId: payment.transaction_id,
        notes: payment.notes,
        paymentType: payment.payment_type,
        isAutoGenerated: payment.is_auto_generated,
        processedBy: payment.processed_by,
        createdAt: payment.created_at
      }));
      
      return { data: transformedData as PaymentData[], error: null };
    }
    
    return { data: [], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};
