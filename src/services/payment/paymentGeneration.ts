import { supabase, handleSupabaseError } from '@/lib/supabase';
import { PaymentData } from './types';
import { getPaymentFrequency, calculateNextDueDate } from '@/lib/utils';

export const generateHistoricalPayments = async (
  leaseId: string, 
  rentAmount: number, 
  firstPaymentDate: string, 
  frequency: string,
  currentDate: string = new Date().toISOString().split('T')[0]
): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    // Get lease details for payment day calculation
    const { data: leaseData, error: leaseError } = await supabase
      .from('leases')
      .select('payment_day, payment_frequency, start_date')
      .eq('id', leaseId)
      .single();
      
    if (leaseError) {
      console.error('Error fetching lease details:', leaseError);
      return { data: null, error: leaseError.message };
    }
    
    const paymentDay = leaseData?.payment_day || null;
    // Use the lease payment frequency if available, otherwise use the provided frequency
    const effectiveFrequency = leaseData?.payment_frequency || frequency;
    
    // Parse dates
    const startDate = new Date(firstPaymentDate);
    const endDate = new Date(currentDate);
    
    if (startDate > endDate) {
      return { data: null, error: "La date du premier paiement ne peut pas être postérieure à la date actuelle" };
    }
    
    // Check if initial payments (deposit/agency fees) already exist
    const { data: existingPayments, error: checkError } = await supabase
      .from('payments')
      .select('id, payment_type')
      .eq('lease_id', leaseId)
      .in('payment_type', ['deposit', 'agency_fee']);
      
    if (checkError) {
      console.error('Error checking for existing payments:', checkError);
      return { data: null, error: checkError.message };
    }
    
    const payments: PaymentData[] = [];
    
    // Initialize the first due date using the provided start date
    let currentDueDate = new Date(startDate);
    let paymentNumber = 1;
    
    // Get today's date for comparison
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Generate payments for each period until current date
    while (currentDueDate <= endDate) {
      const dueDateStr = currentDueDate.toISOString().split('T')[0];
      const dueDateObj = new Date(dueDateStr);
      dueDateObj.setHours(0, 0, 0, 0);
      
      // Determine if this is a past due date (due date is before or equal to today)
      const isPastDue = dueDateObj <= today;
      
      // For past due dates, set payment date to the due date
      // For future due dates, set payment date to null (but we'll use current date at insert time to avoid NOT NULL constraint)
      const payment: PaymentData = {
        leaseId,
        amount: rentAmount,
        dueDate: dueDateStr,
        paymentDate: isPastDue ? dueDateStr : currentDate, // Use current date for future payments to satisfy DB constraints
        paymentMethod: 'bank_transfer',
        status: isPastDue ? 'undefined' : 'pending', // Past due payments are undefined, future are pending
        paymentType: 'rent',
        isAutoGenerated: true,
        notes: `Paiement régulier #${paymentNumber} généré automatiquement`
      };
      
      payments.push(payment);
      
      // Calculate the next due date based on frequency and payment day
      // This is the key function for correct date calculation
      currentDueDate = calculateNextDueDate(
        currentDueDate.toISOString().split('T')[0],
        effectiveFrequency,
        paymentDay,
        currentDueDate
      );
      
      paymentNumber++;
    }
    
    // Insert payments to database
    if (payments.length > 0) {
      const paymentsToInsert = payments.map(p => ({
        lease_id: p.leaseId,
        amount: p.amount,
        due_date: p.dueDate,
        payment_date: p.paymentDate, // This will now always have a value
        payment_method: p.paymentMethod,
        status: p.status,
        payment_type: p.paymentType,
        is_auto_generated: p.isAutoGenerated,
        notes: p.notes
      }));
      
      const { data, error } = await supabase
        .from('payments')
        .insert(paymentsToInsert)
        .select();
        
      if (error) return handleSupabaseError(error);
      
      // Transform snake_case to camelCase for the return value
      const transformedData = data.map(payment => ({
        id: payment.id,
        leaseId: payment.lease_id,
        amount: payment.amount,
        paymentDate: payment.payment_date,
        dueDate: payment.due_date,
        paymentMethod: payment.payment_method,
        status: payment.status,
        transactionId: payment.transaction_id,
        notes: payment.notes,
        paymentType: payment.payment_type,
        isAutoGenerated: payment.is_auto_generated,
        processedBy: payment.processed_by,
        createdAt: payment.created_at
      }));
      
      return { data: transformedData as PaymentData[], error: null };
    }
    
    return { data: [], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};
