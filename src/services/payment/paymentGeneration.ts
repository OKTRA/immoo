
import { supabase, handleSupabaseError } from '@/lib/supabase';
import { PaymentData } from './types';
import { getPaymentFrequency, calculateNextDueDate } from '@/lib/utils';

export const generateHistoricalPayments = async (
  leaseId: string, 
  rentAmount: number, 
  firstPaymentDate: string, 
  frequency: string,
  currentDate: string = new Date().toISOString().split('T')[0]
): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    // Get lease details for payment day calculation
    const { data: leaseData, error: leaseError } = await supabase
      .from('leases')
      .select('payment_day, payment_frequency, start_date')
      .eq('id', leaseId)
      .single();
      
    if (leaseError) {
      console.error('Error fetching lease details:', leaseError);
      return { data: null, error: leaseError.message };
    }
    
    const paymentDay = leaseData?.payment_day || null;
    // Use the lease payment frequency if available, otherwise use the provided frequency
    const effectiveFrequency = leaseData?.payment_frequency || frequency;
    
    // Parse dates
    const startDate = new Date(firstPaymentDate);
    const endDate = new Date(currentDate);
    
    if (startDate > endDate) {
      return { data: null, error: "La date du premier paiement ne peut pas être postérieure à la date actuelle" };
    }
    
    // Check if initial payments (deposit/agency fees) already exist
    const { data: existingPayments, error: checkError } = await supabase
      .from('payments')
      .select('id, payment_type')
      .eq('lease_id', leaseId)
      .in('payment_type', ['deposit', 'agency_fee', 'initial']);
      
    if (checkError) {
      console.error('Error checking for existing payments:', checkError);
      return { data: null, error: checkError.message };
    }
    
    const payments: PaymentData[] = [];
    
    // Initialize the first due date using the provided start date
    let currentDueDate = new Date(startDate);
    let paymentNumber = 1;
    
    // Generate payments for each period until current date
    while (currentDueDate <= endDate) {
      const payment: PaymentData = {
        leaseId,
        amount: rentAmount,
        dueDate: currentDueDate.toISOString().split('T')[0],
        paymentDate: null, // Set to null by default, meaning not paid yet
        paymentMethod: 'bank_transfer',
        status: 'undefined', // Will be calculated on the front-end based on dates
        paymentType: 'rent',
        isAutoGenerated: true,
        notes: `Paiement régulier #${paymentNumber} généré automatiquement`
      };
      
      payments.push(payment);
      
      // Calculate the next due date based on frequency and payment day
      // This is the key function for correct date calculation
      currentDueDate = calculateNextDueDate(
        firstPaymentDate,
        effectiveFrequency,
        paymentDay,
        currentDueDate
      );
      
      paymentNumber++;
    }
    
    // Insert payments to database
    if (payments.length > 0) {
      const paymentsToInsert = payments.map(p => ({
        lease_id: p.leaseId,
        amount: p.amount,
        due_date: p.dueDate,
        payment_date: p.paymentDate, // This will be null for most payments
        payment_method: p.paymentMethod,
        status: p.status,
        payment_type: p.paymentType,
        is_auto_generated: p.isAutoGenerated,
        notes: p.notes
      }));
      
      const { data, error } = await supabase
        .from('payments')
        .insert(paymentsToInsert)
        .select();
        
      if (error) return handleSupabaseError(error);
      
      // Transform snake_case to camelCase for the return value
      const transformedData = data.map(payment => ({
        id: payment.id,
        leaseId: payment.lease_id,
        amount: payment.amount,
        paymentDate: payment.payment_date,
        dueDate: payment.due_date,
        paymentMethod: payment.payment_method,
        status: payment.status,
        transactionId: payment.transaction_id,
        notes: payment.notes,
        paymentType: payment.payment_type,
        isAutoGenerated: payment.is_auto_generated,
        processedBy: payment.processed_by,
        createdAt: payment.created_at
      }));
      
      return { data: transformedData as PaymentData[], error: null };
    }
    
    return { data: [], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};
