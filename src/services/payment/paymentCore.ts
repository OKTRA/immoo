import { supabase, handleSupabaseError } from '@/lib/supabase';
import { toast } from 'sonner';
import { PaymentData } from './types';

export const createPayment = async (paymentData: PaymentData) => {
  try {
    if (!paymentData.leaseId) {
      toast.error('LeaseId is required for payment creation');
      return { data: null, error: 'LeaseId is required' };
    }

    const { data, error } = await supabase
      .from('payments')
      .insert({
        lease_id: paymentData.leaseId,
        amount: paymentData.amount,
        payment_date: paymentData.paymentDate || new Date().toISOString().split('T')[0], // Ensure payment_date is never null
        due_date: paymentData.dueDate,
        payment_method: paymentData.paymentMethod,
        status: paymentData.status,
        transaction_id: paymentData.transactionId,
        notes: paymentData.notes,
        payment_type: paymentData.paymentType,
        is_auto_generated: paymentData.isAutoGenerated,
        processed_by: paymentData.processedBy
      })
      .select()
      .single();

    if (error) return handleSupabaseError(error);

    // Créer commission si applicable
    await createCommissionForPayment(data);
    return { data, error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const getPaymentsByLeaseId = async (leaseId: string): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    const { data, error } = await supabase
      .from('payments')
      .select('*')
      .eq('lease_id', leaseId)
      .order('due_date', { ascending: true });

    if (error) return handleSupabaseError(error);

    // Transform snake_case to camelCase
    const transformedData = data.map(payment => ({
      id: payment.id,
      leaseId: payment.lease_id,
      amount: payment.amount,
      paymentDate: payment.payment_date,
      dueDate: payment.due_date,
      paymentMethod: payment.payment_method,
      status: payment.status,
      transactionId: payment.transaction_id,
      notes: payment.notes,
      paymentType: payment.payment_type || 'rent',
      isAutoGenerated: payment.is_auto_generated || false,
      processedBy: payment.processed_by,
      createdAt: payment.created_at
    }));

    return { data: transformedData as PaymentData[], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const updatePayment = async (paymentId: string, paymentData: Partial<PaymentData>) => {
  try {
    const updateData: any = {};
    
    if (paymentData.amount !== undefined) updateData.amount = paymentData.amount;
    if (paymentData.paymentDate !== undefined) updateData.payment_date = paymentData.paymentDate;
    if (paymentData.dueDate !== undefined) updateData.due_date = paymentData.dueDate;
    if (paymentData.paymentMethod !== undefined) updateData.payment_method = paymentData.paymentMethod;
    if (paymentData.status !== undefined) updateData.status = paymentData.status;
    if (paymentData.transactionId !== undefined) updateData.transaction_id = paymentData.transactionId;
    if (paymentData.notes !== undefined) updateData.notes = paymentData.notes;
    if (paymentData.paymentType !== undefined) updateData.payment_type = paymentData.paymentType;
    if (paymentData.processedBy !== undefined) updateData.processed_by = paymentData.processedBy;
    
    const { data, error } = await supabase
      .from('payments')
      .update(updateData)
      .eq('id', paymentId)
      .select()
      .single();

    if (error) return handleSupabaseError(error);

    // Créer commission si applicable
    await createCommissionForPayment(data);
    return { data, error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const deletePayment = async (paymentId: string): Promise<{ success: boolean; error: string | null }> => {
  try {
    const { error } = await supabase
      .from('payments')
      .delete()
      .eq('id', paymentId);

    if (error) {
      console.error('Error deleting payment:', error);
      return { success: false, error: error.message || 'Failed to delete payment' };
    }

    return { success: true, error: null };
  } catch (error: any) {
    console.error('Error in deletePayment:', error);
    return { success: false, error: error.message || 'An unknown error occurred' };
  }
};

export const getLeaseWithPayments = async (leaseId: string) => {
  try {
    // Get lease details
    const { data: leaseData, error: leaseError } = await supabase
      .from('leases')
      .select(`
        *,
        properties(*),
        tenants(*)
      `)
      .eq('id', leaseId)
      .single();
    
    if (leaseError) return { lease: null, payments: null, error: leaseError.message };
    
    // Get payments for this lease
    const { data: payments, error: paymentsError } = await getPaymentsByLeaseId(leaseId);
    
    if (paymentsError) return { lease: leaseData, payments: null, error: paymentsError };
    
    return { lease: leaseData, payments, error: null };
  } catch (error: any) {
    console.error('Error getting lease with payments:', error);
    return { lease: null, payments: null, error: error.message || 'An unknown error occurred' };
  }
};

// Helper: créer une commission pour un paiement de loyer
export async function createCommissionForPayment(payment: any) {
  try {
    if (payment.payment_type !== 'rent') return;
    if (!(payment.status === 'paid' || payment.status === 'advanced')) return;

    // Vérifier si la commission existe déjà
    const { data: existing } = await supabase
      .from('commissions')
      .select('id')
      .eq('payment_id', payment.id)
      .maybeSingle();
    if (existing) return;

    // Récupérer propriété pour le taux
    const { data: leaseData } = await supabase
      .from('leases')
      .select('property_id')
      .eq('id', payment.lease_id)
      .single();
    if (!leaseData) return;

    const { data: propertyData } = await supabase
      .from('properties')
      .select('agency_commission_rate')
      .eq('id', leaseData.property_id)
      .single();
    const rate = propertyData?.agency_commission_rate || 0;
    if (rate <= 0) return;

    const commissionAmount = (payment.amount || 0) * rate / 100;

    await supabase.from('commissions').insert({
      payment_id: payment.id,
      lease_id: payment.lease_id,
      property_id: leaseData.property_id,
      amount: commissionAmount,
      rate,
      status: 'paid',
    });
  } catch (err) {
    console.error('Erreur création commission:', err);
  }
}
