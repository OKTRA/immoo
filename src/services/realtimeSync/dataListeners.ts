import { supabase } from '@/lib/supabase';
import { realtimeSyncService } from './syncService';
import { realtimeErrorHandler } from './errorHandler';

// Types pour les donn√©es critiques
interface Property {
  id: string;
  title: string;
  description?: string;
  price: number;
  status: 'available' | 'rented' | 'sold' | 'maintenance';
  owner_id: string;
  created_at: string;
  updated_at: string;
}

interface Lease {
  id: string;
  property_id: string;
  tenant_id: string;
  start_date: string;
  end_date: string;
  monthly_rent: number;
  status: 'active' | 'expired' | 'terminated';
  created_at: string;
  updated_at: string;
}

interface Payment {
  id: string;
  lease_id: string;
  amount: number;
  payment_date: string;
  due_date: string;
  status: 'pending' | 'paid' | 'overdue' | 'cancelled';
  payment_method?: string;
  created_at: string;
  updated_at: string;
}

interface UserProfile {
  id: string;
  email: string;
  full_name?: string;
  avatar_url?: string;
  role: 'owner' | 'tenant' | 'admin';
  phone?: string;
  updated_at: string;
}

// Service de gestion des listeners pour les donn√©es critiques
class DataListenersService {
  private activeListeners: Set<string> = new Set();
  private dataCache: Map<string, any[]> = new Map();
  private callbacks: Map<string, Set<(data: any) => void>> = new Map();

  /**
   * Initialise tous les listeners pour les donn√©es critiques
   */
  async initializeAllListeners(userId?: string): Promise<void> {
    console.log('üéØ Initializing data listeners for critical tables...');
    
    try {
      // Initialiser le service de synchronisation
      await realtimeSyncService.initialize();
      
      // D√©marrer les listeners pour chaque table critique
      this.startPropertiesListener(userId);
      this.startLeasesListener(userId);
      this.startPaymentsListener(userId);
      this.startProfilesListener(userId);
      
      console.log('‚úÖ All data listeners initialized successfully');
    } catch (error) {
      console.error('‚ùå Failed to initialize data listeners:', error);
      realtimeErrorHandler.reportError(
        'data',
        'critical',
        'Failed to initialize all data listeners',
        error
      );
      throw error;
    }
  }

  /**
   * Listener pour les propri√©t√©s
   */
  private startPropertiesListener(userId?: string): void {
    const listenerId = 'properties_listener';
    
    if (this.activeListeners.has(listenerId)) {
      console.log('‚ö†Ô∏è Properties listener already active');
      return;
    }

    const filter = userId ? `owner_id=eq.${userId}` : undefined;
    
    const subscriptionId = realtimeSyncService.subscribe(
      'properties',
      (payload) => this.handlePropertyChange(payload),
      { filter }
    );
    
    this.activeListeners.add(listenerId);
    console.log(`üì° Properties listener started with filter: ${filter || 'none'}`);
  }

  /**
   * Listener pour les baux
   */
  private startLeasesListener(userId?: string): void {
    const listenerId = 'leases_listener';
    
    if (this.activeListeners.has(listenerId)) {
      console.log('‚ö†Ô∏è Leases listener already active');
      return;
    }

    // Pour les baux, on peut filtrer par propri√©taire via une jointure
    // ou √©couter tous les changements si l'utilisateur est admin
    const subscriptionId = realtimeSyncService.subscribe(
      'leases',
      (payload) => this.handleLeaseChange(payload)
    );
    
    this.activeListeners.add(listenerId);
    console.log('üì° Leases listener started');
  }

  /**
   * Listener pour les paiements
   */
  private startPaymentsListener(userId?: string): void {
    const listenerId = 'payments_listener';
    
    if (this.activeListeners.has(listenerId)) {
      console.log('‚ö†Ô∏è Payments listener already active');
      return;
    }

    const subscriptionId = realtimeSyncService.subscribe(
      'payments',
      (payload) => this.handlePaymentChange(payload)
    );
    
    this.activeListeners.add(listenerId);
    console.log('üì° Payments listener started');
  }

  /**
   * Listener pour les profils utilisateur
   */
  private startProfilesListener(userId?: string): void {
    const listenerId = 'profiles_listener';
    
    if (this.activeListeners.has(listenerId)) {
      console.log('‚ö†Ô∏è Profiles listener already active');
      return;
    }

    const filter = userId ? `id=eq.${userId}` : undefined;
    
    const subscriptionId = realtimeSyncService.subscribe(
      'profiles',
      (payload) => this.handleProfileChange(payload),
      { filter }
    );
    
    this.activeListeners.add(listenerId);
    console.log(`üì° Profiles listener started with filter: ${filter || 'none'}`);
  }

  /**
   * Gestionnaire des changements de propri√©t√©s
   */
  private handlePropertyChange(payload: any): void {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    console.log(`üè† Property ${eventType}:`, { new: newRecord, old: oldRecord });
    
    // Mettre √† jour le cache local
    this.updateCache('properties', eventType, newRecord, oldRecord);
    
    // Notifier les composants abonn√©s
    this.notifyCallbacks('properties', { eventType, new: newRecord, old: oldRecord });
    
    // Actions sp√©cifiques selon le type d'√©v√©nement
    switch (eventType) {
      case 'INSERT':
        console.log(`‚ú® Nouvelle propri√©t√© ajout√©e: ${newRecord.title}`);
        break;
      case 'UPDATE':
        console.log(`üìù Propri√©t√© mise √† jour: ${newRecord.title}`);
        if (oldRecord.status !== newRecord.status) {
          console.log(`üîÑ Statut chang√©: ${oldRecord.status} ‚Üí ${newRecord.status}`);
        }
        break;
      case 'DELETE':
        console.log(`üóëÔ∏è Propri√©t√© supprim√©e: ${oldRecord.title}`);
        break;
    }
  }

  /**
   * Gestionnaire des changements de baux
   */
  private handleLeaseChange(payload: any): void {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    console.log(`üìã Lease ${eventType}:`, { new: newRecord, old: oldRecord });
    
    this.updateCache('leases', eventType, newRecord, oldRecord);
    this.notifyCallbacks('leases', { eventType, new: newRecord, old: oldRecord });
    
    switch (eventType) {
      case 'INSERT':
        console.log(`‚ú® Nouveau bail cr√©√© pour la propri√©t√© ${newRecord.property_id}`);
        break;
      case 'UPDATE':
        console.log(`üìù Bail mis √† jour: ${newRecord.id}`);
        if (oldRecord.status !== newRecord.status) {
          console.log(`üîÑ Statut du bail chang√©: ${oldRecord.status} ‚Üí ${newRecord.status}`);
        }
        break;
      case 'DELETE':
        console.log(`üóëÔ∏è Bail supprim√©: ${oldRecord.id}`);
        break;
    }
  }

  /**
   * Gestionnaire des changements de paiements
   */
  private handlePaymentChange(payload: any): void {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    console.log(`üí∞ Payment ${eventType}:`, { new: newRecord, old: oldRecord });
    
    this.updateCache('payments', eventType, newRecord, oldRecord);
    this.notifyCallbacks('payments', { eventType, new: newRecord, old: oldRecord });
    
    switch (eventType) {
      case 'INSERT':
        console.log(`‚ú® Nouveau paiement enregistr√©: ${newRecord.amount}‚Ç¨`);
        break;
      case 'UPDATE':
        console.log(`üìù Paiement mis √† jour: ${newRecord.id}`);
        if (oldRecord.status !== newRecord.status) {
          console.log(`üîÑ Statut du paiement chang√©: ${oldRecord.status} ‚Üí ${newRecord.status}`);
          if (newRecord.status === 'paid') {
            console.log(`‚úÖ Paiement confirm√©: ${newRecord.amount}‚Ç¨`);
          }
        }
        break;
      case 'DELETE':
        console.log(`üóëÔ∏è Paiement supprim√©: ${oldRecord.id}`);
        break;
    }
  }

  /**
   * Gestionnaire des changements de profils
   */
  private handleProfileChange(payload: any): void {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    console.log(`üë§ Profile ${eventType}:`, { new: newRecord, old: oldRecord });
    
    this.updateCache('profiles', eventType, newRecord, oldRecord);
    this.notifyCallbacks('profiles', { eventType, new: newRecord, old: oldRecord });
    
    switch (eventType) {
      case 'INSERT':
        console.log(`‚ú® Nouveau profil cr√©√©: ${newRecord.email}`);
        break;
      case 'UPDATE':
        console.log(`üìù Profil mis √† jour: ${newRecord.email}`);
        break;
      case 'DELETE':
        console.log(`üóëÔ∏è Profil supprim√©: ${oldRecord.email}`);
        break;
    }
  }

  /**
   * Met √† jour le cache local des donn√©es
   */
  private updateCache(table: string, eventType: string, newRecord: any, oldRecord: any): void {
    const cacheKey = table;
    let cachedData = this.dataCache.get(cacheKey) || [];
    
    switch (eventType) {
      case 'INSERT':
        cachedData.push(newRecord);
        break;
      case 'UPDATE':
        const updateIndex = cachedData.findIndex(item => item.id === newRecord.id);
        if (updateIndex !== -1) {
          cachedData[updateIndex] = newRecord;
        }
        break;
      case 'DELETE':
        cachedData = cachedData.filter(item => item.id !== oldRecord.id);
        break;
    }
    
    this.dataCache.set(cacheKey, cachedData);
  }

  /**
   * Notifie les callbacks enregistr√©s
   */
  private notifyCallbacks(table: string, data: any): void {
    const callbacks = this.callbacks.get(table);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`‚ùå Error in callback for ${table}:`, error);
          realtimeErrorHandler.reportError(
            'data',
            'medium',
            `Error in ${table} data handler`,
            error
          );
        }
      });
    }
  }

  /**
   * Enregistre un callback pour une table
   */
  registerCallback(table: string, callback: (data: any) => void): () => void {
    if (!this.callbacks.has(table)) {
      this.callbacks.set(table, new Set());
    }
    
    this.callbacks.get(table)!.add(callback);
    
    // Retourne une fonction de nettoyage
    return () => {
      this.callbacks.get(table)?.delete(callback);
    };
  }

  /**
   * Obtient les donn√©es en cache pour une table
   */
  getCachedData(table: string): any[] {
    return this.dataCache.get(table) || [];
  }

  /**
   * Arr√™te tous les listeners
   */
  stopAllListeners(): void {
    console.log('üõë Stopping all data listeners...');
    realtimeSyncService.unsubscribeAll();
    this.activeListeners.clear();
    this.dataCache.clear();
    this.callbacks.clear();
    console.log('‚úÖ All data listeners stopped');
  }

  /**
   * Red√©marre tous les listeners
   */
  async restartAllListeners(userId?: string): Promise<void> {
    console.log('üîÑ Restarting all data listeners...');
    this.stopAllListeners();
    await this.initializeAllListeners(userId);
  }

  /**
   * Obtient le statut des listeners
   */
  getListenersStatus(): {
    active: string[];
    serviceConnected: boolean;
    cacheSize: Record<string, number>;
  } {
    const cacheSize: Record<string, number> = {};
    for (const [table, data] of this.dataCache) {
      cacheSize[table] = data.length;
    }
    
    return {
      active: Array.from(this.activeListeners),
      serviceConnected: realtimeSyncService.isServiceConnected(),
      cacheSize
    };
  }
}

// Instance singleton du service
export const dataListenersService = new DataListenersService();

// Types export√©s
export type { Property, Lease, Payment, UserProfile };
export { DataListenersService };