
import { supabase, handleSupabaseError, getMockData, addDatePeriod, getDateDiff } from '@/lib/supabase';
import { toast } from 'sonner';

export interface PaymentData {
  id?: string;
  leaseId: string;
  amount: number;
  paymentDate?: string | null;
  dueDate?: string | null;
  paymentMethod: string;
  status: 'paid' | 'pending' | 'late' | 'cancelled' | 'undefined';
  transactionId?: string | null;
  notes?: string | null;
  paymentType: 'initial' | 'rent' | 'deposit' | 'deposit_return' | 'agency_fee' | 'other';
  isAutoGenerated: boolean;
  processedBy?: string | null;
  createdAt?: string;
}

export interface PaymentFrequency {
  value: 'daily' | 'weekly' | 'biweekly' | 'monthly' | 'quarterly' | 'biannually' | 'annually';
  label: string;
  daysInterval: number;
  periodUnit: 'days' | 'weeks' | 'months' | 'years';
  periodAmount: number;
}

export const PAYMENT_FREQUENCIES: PaymentFrequency[] = [
  { value: 'daily', label: 'Quotidien', daysInterval: 1, periodUnit: 'days', periodAmount: 1 },
  { value: 'weekly', label: 'Hebdomadaire', daysInterval: 7, periodUnit: 'weeks', periodAmount: 1 },
  { value: 'biweekly', label: 'Bi-hebdomadaire', daysInterval: 14, periodUnit: 'weeks', periodAmount: 2 },
  { value: 'monthly', label: 'Mensuel', daysInterval: 30, periodUnit: 'months', periodAmount: 1 },
  { value: 'quarterly', label: 'Trimestriel', daysInterval: 90, periodUnit: 'months', periodAmount: 3 },
  { value: 'biannually', label: 'Semestriel', daysInterval: 180, periodUnit: 'months', periodAmount: 6 },
  { value: 'annually', label: 'Annuel', daysInterval: 365, periodUnit: 'years', periodAmount: 1 },
];

export const getPaymentFrequency = (value: string): PaymentFrequency => {
  return PAYMENT_FREQUENCIES.find(f => f.value === value) || PAYMENT_FREQUENCIES[3]; // default to monthly
};

export const createPayment = async (paymentData: PaymentData) => {
  try {
    if (!paymentData.leaseId) {
      toast.error('LeaseId is required for payment creation');
      return { data: null, error: 'LeaseId is required' };
    }

    const { data, error } = await supabase
      .from('payments')
      .insert({
        lease_id: paymentData.leaseId,
        amount: paymentData.amount,
        payment_date: paymentData.paymentDate || new Date().toISOString().split('T')[0], // Ensure payment_date is never null
        due_date: paymentData.dueDate,
        payment_method: paymentData.paymentMethod,
        status: paymentData.status,
        transaction_id: paymentData.transactionId,
        notes: paymentData.notes,
        payment_type: paymentData.paymentType,
        is_auto_generated: paymentData.isAutoGenerated,
        processed_by: paymentData.processedBy
      })
      .select()
      .single();

    if (error) return handleSupabaseError(error);

    return { data, error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const getPaymentsByLeaseId = async (leaseId: string): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    const { data, error } = await supabase
      .from('payments')
      .select('*')
      .eq('lease_id', leaseId)
      .order('due_date', { ascending: true });

    if (error) return handleSupabaseError(error);

    // Transform snake_case to camelCase
    const transformedData = data.map(payment => ({
      id: payment.id,
      leaseId: payment.lease_id,
      amount: payment.amount,
      paymentDate: payment.payment_date,
      dueDate: payment.due_date,
      paymentMethod: payment.payment_method,
      status: payment.status,
      transactionId: payment.transaction_id,
      notes: payment.notes,
      paymentType: payment.payment_type || 'rent',
      isAutoGenerated: payment.is_auto_generated || false,
      processedBy: payment.processed_by,
      createdAt: payment.created_at
    }));

    return { data: transformedData as PaymentData[], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const updatePayment = async (paymentId: string, paymentData: Partial<PaymentData>) => {
  try {
    const updateData: any = {};
    
    if (paymentData.amount !== undefined) updateData.amount = paymentData.amount;
    if (paymentData.paymentDate !== undefined) updateData.payment_date = paymentData.paymentDate;
    if (paymentData.dueDate !== undefined) updateData.due_date = paymentData.dueDate;
    if (paymentData.paymentMethod !== undefined) updateData.payment_method = paymentData.paymentMethod;
    if (paymentData.status !== undefined) updateData.status = paymentData.status;
    if (paymentData.transactionId !== undefined) updateData.transaction_id = paymentData.transactionId;
    if (paymentData.notes !== undefined) updateData.notes = paymentData.notes;
    if (paymentData.paymentType !== undefined) updateData.payment_type = paymentData.paymentType;
    if (paymentData.processedBy !== undefined) updateData.processed_by = paymentData.processedBy;
    
    const { data, error } = await supabase
      .from('payments')
      .update(updateData)
      .eq('id', paymentId)
      .select()
      .single();

    if (error) return handleSupabaseError(error);

    return { data, error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

export const deletePayment = async (paymentId: string): Promise<{ success: boolean; error: string | null }> => {
  try {
    const { error } = await supabase
      .from('payments')
      .delete()
      .eq('id', paymentId);

    if (error) {
      console.error('Error deleting payment:', error);
      return { success: false, error: error.message || 'Failed to delete payment' };
    }

    return { success: true, error: null };
  } catch (error: any) {
    console.error('Error in deletePayment:', error);
    return { success: false, error: error.message || 'An unknown error occurred' };
  }
};

export const generateHistoricalPayments = async (
  leaseId: string, 
  rentAmount: number, 
  firstPaymentDate: string, 
  frequency: string,
  currentDate: string = new Date().toISOString().split('T')[0]
): Promise<{ data: PaymentData[] | null; error: string | null }> => {
  try {
    const paymentFrequency = getPaymentFrequency(frequency);
    const startDate = new Date(firstPaymentDate);
    const endDate = new Date(currentDate);
    
    if (startDate > endDate) {
      return { data: null, error: "La date du premier paiement ne peut pas être postérieure à la date actuelle" };
    }
    
    // Check if initial payments (deposit/agency fees) already exist
    const { data: existingPayments, error: checkError } = await supabase
      .from('payments')
      .select('id, payment_type')
      .eq('lease_id', leaseId)
      .in('payment_type', ['deposit', 'agency_fee', 'initial']);
      
    if (checkError) {
      console.error('Error checking for existing payments:', checkError);
      return { data: null, error: checkError.message };
    }
    
    const payments: PaymentData[] = [];
    let currentDueDate = new Date(startDate);
    
    // Generate regular payments until current date
    let paymentNumber = 1;
    while (true) {
      if (paymentNumber > 1) {
        // Add the frequency interval for subsequent payments
        currentDueDate = addDatePeriod(
          currentDueDate, 
          paymentFrequency.periodAmount, 
          paymentFrequency.periodUnit
        );
      }
      
      // Stop if we've gone past the current date
      if (currentDueDate > endDate) break;
      
      const payment: PaymentData = {
        leaseId,
        amount: rentAmount,
        dueDate: currentDueDate.toISOString().split('T')[0],
        paymentDate: currentDueDate.toISOString().split('T')[0], // Add payment_date to fix the not-null constraint error
        paymentMethod: 'bank_transfer',
        status: 'undefined',
        paymentType: 'rent',
        isAutoGenerated: true,
        notes: `Paiement régulier #${paymentNumber} généré automatiquement`
      };
      
      payments.push(payment);
      paymentNumber++;
    }
    
    // Insert payments to database
    if (payments.length > 0) {
      const paymentsToInsert = payments.map(p => ({
        lease_id: p.leaseId,
        amount: p.amount,
        due_date: p.dueDate,
        payment_date: p.paymentDate, // Include payment_date in the insert
        payment_method: p.paymentMethod,
        status: p.status,
        payment_type: p.paymentType,
        is_auto_generated: p.isAutoGenerated,
        notes: p.notes
      }));
      
      const { data, error } = await supabase
        .from('payments')
        .insert(paymentsToInsert)
        .select();
        
      if (error) return handleSupabaseError(error);
      
      // Transform snake_case to camelCase for the return value
      const transformedData = data.map(payment => ({
        id: payment.id,
        leaseId: payment.lease_id,
        amount: payment.amount,
        paymentDate: payment.payment_date,
        dueDate: payment.due_date,
        paymentMethod: payment.payment_method,
        status: payment.status,
        transactionId: payment.transaction_id,
        notes: payment.notes,
        paymentType: payment.payment_type,
        isAutoGenerated: payment.is_auto_generated,
        processedBy: payment.processed_by,
        createdAt: payment.created_at
      }));
      
      return { data: transformedData as PaymentData[], error: null };
    }
    
    return { data: [], error: null };
  } catch (error) {
    return handleSupabaseError(error);
  }
};

interface BulkUpdateParams {
  paymentIds: string[];
  status: 'paid' | 'pending' | 'late' | 'cancelled' | 'undefined';
  notes?: string;
  userId?: string;
}

export const updateBulkPayments = async ({ paymentIds, status, notes, userId }: BulkUpdateParams): Promise<{ success: boolean; error: string | null }> => {
  try {
    if (!paymentIds.length) {
      return { success: false, error: "Aucun paiement sélectionné" };
    }
    
    // Start a Supabase transaction by creating a bulk update record first
    const { data: bulkUpdateData, error: bulkUpdateError } = await supabase
      .from('payment_bulk_updates')
      .insert({
        user_id: userId,
        payments_count: paymentIds.length,
        status,
        notes
      })
      .select()
      .single();
      
    if (bulkUpdateError) return { success: false, error: bulkUpdateError.message };
    
    // Get previous status of each payment before updating
    const { data: previousStatusData, error: previousStatusError } = await supabase
      .from('payments')
      .select('id, status')
      .in('id', paymentIds);
      
    if (previousStatusError) return { success: false, error: previousStatusError.message };
    
    // Create a map of payment ID to previous status
    const previousStatusMap = previousStatusData.reduce((acc, curr) => {
      acc[curr.id] = curr.status;
      return acc;
    }, {} as Record<string, string>);
    
    // Update all payments
    const { error: updateError } = await supabase
      .from('payments')
      .update({ 
        status, 
        notes: notes ? notes : undefined,
        processed_by: userId ? userId : undefined
      })
      .in('id', paymentIds);
      
    if (updateError) return { success: false, error: updateError.message };
    
    // Create bulk update items for tracking
    const bulkUpdateItems = paymentIds.map(paymentId => ({
      bulk_update_id: bulkUpdateData.id,
      payment_id: paymentId,
      previous_status: previousStatusMap[paymentId] || null,
      new_status: status
    }));
    
    const { error: itemsError } = await supabase
      .from('payment_bulk_update_items')
      .insert(bulkUpdateItems);
      
    if (itemsError) {
      console.error('Error creating bulk update items:', itemsError);
      // We don't return an error here as the payments were already updated
    }
    
    return { success: true, error: null };
  } catch (error: any) {
    console.error('Error in bulk update:', error);
    return { success: false, error: error.message || "Une erreur est survenue lors de la mise à jour en masse" };
  }
};

export const getLeaseWithPayments = async (leaseId: string) => {
  try {
    // Get lease details
    const { data: leaseData, error: leaseError } = await supabase
      .from('leases')
      .select(`
        *,
        properties(*),
        tenants(*)
      `)
      .eq('id', leaseId)
      .single();
    
    if (leaseError) return { lease: null, payments: null, error: leaseError.message };
    
    // Get payments for this lease
    const { data: payments, error: paymentsError } = await getPaymentsByLeaseId(leaseId);
    
    if (paymentsError) return { lease: leaseData, payments: null, error: paymentsError };
    
    return { lease: leaseData, payments, error: null };
  } catch (error: any) {
    console.error('Error getting lease with payments:', error);
    return { lease: null, payments: null, error: error.message || 'An unknown error occurred' };
  }
};

export const getLeasePaymentStats = async (leaseId: string) => {
  try {
    const { data: payments, error } = await getPaymentsByLeaseId(leaseId);
    
    if (error) return { stats: null, error };
    
    const stats = {
      totalPaid: 0,
      totalDue: 0,
      pendingPayments: 0,
      latePayments: 0,
      undefinedPayments: 0,
      balance: 0
    };
    
    if (payments) {
      payments.forEach(payment => {
        // Add to total due
        stats.totalDue += payment.amount;
        
        // Calculate based on status
        if (payment.status === 'paid') {
          stats.totalPaid += payment.amount;
        } else if (payment.status === 'pending') {
          stats.pendingPayments++;
        } else if (payment.status === 'late') {
          stats.latePayments++;
        } else if (payment.status === 'undefined') {
          stats.undefinedPayments++;
        }
      });
      
      // Calculate balance
      stats.balance = stats.totalDue - stats.totalPaid;
    }
    
    return { stats, error: null };
  } catch (error: any) {
    console.error('Error calculating lease payment stats:', error);
    return { stats: null, error: error.message || 'An unknown error occurred' };
  }
};

export const getPaymentTotalsByType = async (leaseId: string) => {
  try {
    const { data, error } = await supabase
      .from('payments')
      .select('payment_type, amount, status')
      .eq('lease_id', leaseId);
      
    if (error) return { totals: null, error: error.message };
    
    const totals = {
      deposit: {
        total: 0,
        paid: 0,
        pending: 0
      },
      agency_fee: {
        total: 0,
        paid: 0,
        pending: 0
      },
      rent: {
        total: 0,
        paid: 0,
        pending: 0
      },
      other: {
        total: 0,
        paid: 0,
        pending: 0
      }
    };
    
    data.forEach(payment => {
      const type = payment.payment_type || 'other';
      const amount = payment.amount || 0;
      
      // Add to total for this payment type
      if (totals[type]) {
        totals[type].total += amount;
        
        // Add to paid or pending based on status
        if (payment.status === 'paid') {
          totals[type].paid += amount;
        } else if (payment.status === 'pending' || payment.status === 'undefined') {
          totals[type].pending += amount;
        }
      } else {
        totals.other.total += amount;
        if (payment.status === 'paid') {
          totals.other.paid += amount;
        } else if (payment.status === 'pending' || payment.status === 'undefined') {
          totals.other.pending += amount;
        }
      }
    });
    
    return { totals, error: null };
  } catch (error: any) {
    console.error('Error calculating payment totals by type:', error);
    return { totals: null, error: error.message };
  }
};
